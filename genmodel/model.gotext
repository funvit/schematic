// Code generated by schematic, DO NOT EDIT.
//
// Schema file: {{.SchemaFile}}

package {{.PackageName}}

{{ $modelName := Title (SnakeToCamel .Name) }}

{{ $stringer := 0 }}
{{- range $idx, $f := .Fields }}
	{{ if $f.ModelStringer }}{{ $stringer = 1}}{{- end}}
{{- end}}

{{ $uuid := 0 }}
{{- range $idx, $f := .Fields }}
	{{ if eq $f.Type.String "uuid.UUID" }}{{ $uuid = 1}}{{- end}}
{{- end}}

{{ $time := 0 }}
{{- range $idx, $f := .Fields }}
	{{ if eq $f.Type.String "time.Time" }}{{ $time = 1}}{{- end}}
{{- end}}

{{ $json := 0 }}
{{- if .SchemaConfig }}{{- if .SchemaConfig.JSON }}{{ $json = 1}}{{- end}}{{- end}}

import (
	{{ if $uuid}}"github.com/google/uuid"{{end}}
	{{ if $time}}"time"{{end}}
	{{ if $stringer}}"strings"{{end}}
	{{ if $stringer}}"fmt"{{end}}
	{{ if $json}}schemagen "github.com/funvit/schematic"{{end}}
	{{ if $json}}"github.com/pkg/errors"{{end}}
)

type {{ $modelName }} struct {
	{{- range $n, $f := .Fields }}
	{{ if $f.Comment }}{{$f.Comment.ForType}}{{end -}}
	{{ SchemaFieldToModel $f }} {{ $f.Type.String }} {{ if $f.Annotate }}{{$f.GetAnnotate}}{{end}}
	{{- end }}
}


{{- if $stringer }}
func (m *{{ $modelName}}) String() string {

	var b strings.Builder

	b.WriteString("<{{$modelName}}")

	{{- range $idx, $f := .Fields }}
		{{- if $f.ModelStringer }}
			b.WriteString(fmt.Sprintf(
				" {{ SchemaFieldToModel $f }}:%v",
				{{- if $f.Sensitive }}
					"******", // sensitive
				{{ else }}
					m.{{ SchemaFieldToModel $f }},
				{{- end}}
			))
		{{- end}}
	{{- end}}

	b.WriteString(">")

	return b.String()
}
{{- end }}

{{- range $idx, $f := .Fields }}
{{- if $f.Getter }}

// Get{{Title (SchemaFieldToModel $f)}} gets field {{SchemaFieldToModel $f}} value.
//
// Generated due to schema field marked with Getter().
//
// Note: getter can help to satisfy some interface(s).
func (m *{{$modelName}}) Get{{Title (SchemaFieldToModel $f)}}() {{$f.Type}} {
	return m.{{SchemaFieldToModel $f}}
}
{{- end}}
{{- end}}

{{- range $idx, $f := .Fields }}
{{- if $f.Setter }}

// Set{{Title (SchemaFieldToModel $f)}} sets field {{SchemaFieldToModel $f}} value.
//
// Generated due to schema field marked with Setter().
//
// Note: setter can help to satisfy some interface(s).
func (m *{{$modelName}}) Set{{Title (SchemaFieldToModel $f)}}(val {{$f.Type}}) {
	m.{{SchemaFieldToModel  $f}} = val
}
{{- end}}
{{- end}}


{{ $defaultConstructor := 0 }}
{{- range $idx, $f := .Fields }}
	{{ if $f.Default }}{{ $defaultConstructor = 1}}{{- end}}
{{- end}}

// {{$modelName}}WithDefaults constructs model {{$modelName}}
// with default values defined in schema.
//
// Example:
//
//    // construct a new model
//    myModel := {{$modelName}}WithDefaults()
//
//    // set public fields directly
//    myModel.SomePublicField = 4221
//
//    // or via setter (if generated)
//    myModel.SetName("Bob")
//
func {{$modelName}}WithDefaults() *{{$modelName}} {
    return &{{$modelName}}{
    {{- range $idx, $f := .Fields }}
        {{- if $f.Default }}
			{{- if eq $f.Type "string" }}
				{{SchemaFieldToModel $f}}: "{{$f.DefaultValue}}",
			{{- else if eq $f.Type "[]byte" }}
				{{SchemaFieldToModel $f}}: []byte{ {{range  $idx, $v := $f.DefaultValue}}{{$v}},{{end}} },
			{{- else if eq $f.Type "uuid.UUID"}}
				{{SchemaFieldToModel $f}}: uuid.MustParse("{{$f.DefaultValue}}"),
			{{- else if eq $f.Type "time.Time"}}
				{{SchemaFieldToModel $f}}: time.Unix({{$f.DefaultValue.Unix}}, {{$f.DefaultValue.Nanosecond}}),
			{{- else }}
 	           {{SchemaFieldToModel $f}}: {{$f.DefaultValue}},
			{{- end}}
        {{- end}}
    {{- end}}
    }
}

{{- if .SchemaConfig }}

{{- if .SchemaConfig.JSON}}

// MarshalJSON .
//
// Generated due to schema config JSON set to true.
//
// Note: schema names are used (Annotate json tags not used).
func (m *{{$modelName}}) MarshalJSON() ([]byte, error) {

	values := make(map[string]interface{}, {{ len .Fields }})

	{{- range $n, $f := .Fields }}
	values["{{$f.Name}}"] = m.{{SchemaFieldToModel $f}}
	{{- end  }}

	return schemagen.MarshalJSON(values, {{Lower .Name}}ModelFields)
}

// UnmarshalJSON .
//
// Generated due to schema config JSON set to true.
//
// Note: schema names are used (Annotate json tags not used).
func (m *{{$modelName}}) UnmarshalJSON(b []byte) error {

	vs, err := schemagen.UnmarshalJSON(b, {{Lower .Name}}ModelFields)
	if err != nil {
		return err
	}

	{{- range $n, $f := .Fields }}
		{{ if IsNumber $f.Type.String }}
			{
				v, ok := vs["{{$f.Name}}"].(int64)
				if !ok {
					return errors.Errorf("json key %s is missing", "{{$f.Name}}")
				}

				m.{{SchemaFieldToModel $f}} = {{$f.Type}}(v)
			}
		{{else}}
			{{ if IsBytes $f.Type.String }}
				{
					v, ok := vs["{{$f.Name}}"].({{$f.Type}})
					if !ok {
						return errors.Errorf(
							"json key %s have unexpected type %T",
							"{{$f.Name}}",
							vs["{{$f.Name}}"],
						)
					}

					if len(v) > 0 {
						m.{{SchemaFieldToModel $f}} = v
					}
				}
			{{else}}
				{
					v, ok := vs["{{$f.Name}}"].({{$f.Type}})
					if !ok {
						return errors.Errorf(
							"json key %s have unexpected type %T",
							"{{$f.Name}}",
							vs["{{$f.Name}}"],
						)
					}

					m.{{SchemaFieldToModel $f}} = v
				}
			{{end}}
		{{end}}
	{{- end}}

	return nil
}

{{- end}}

{{- end}}
